<!DOCTYPE html>
<html lang="zh">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link href="mui.css" rel="stylesheet" />
	<title>KKL</title>
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		canvas {
			position: absolute;
			bottom: 0;
			left: 0;
		}

		.toolbar {
			position: absolute;
			top: 0;
			left: 0;
			height: 80px;
			width: 100%;
			background-color: #ccc;
			z-index: 20;
		}

		.tool {
			display: inline-block;
			height: 50px;
			width: 50px;
			margin-left: 20px;
		}

		.block {
			position: absolute;
			top: 0;
			right: -500px;
			z-index: 999;
		}

		#scale {
			position: absolute;
			bottom: 20px;
			right: 20px;
			height: 10px;
			width: 100px;
			border-style: solid;
			border-color: #000;
			border-width: 0 1px 1px;
			text-align: center;
			line-height: 40px;
			font-size: 12px;
		}
	</style>

</head>

<body>
	<div class="toolbar"></div>
	<canvas id="canvas"></canvas>
	<div id="scale"></div>
	<script type="text/javascript" src="mui.js"></script>
	<script>
        "use strict";
		// ----------common-----------
		mui.init();
		var SCREEN = {};
		SCREEN.width = 1024;
		SCREEN.height = 768;
		SCREEN.topbar = 20;
		var TOOLBAR = {};
		TOOLBAR.width = SCREEN.width;
		TOOLBAR.height = 80;
        var data = JSON.parse(localStorage.getItem("gauge_data"))
		var INIT = data.INIT;
		var OUT = data.OUT;
		var IN = data.IN;
		var scale = data.scale;

		// --------Init objects----------
		var toolbar = document.getElementsByClassName("toolbar")[0];
		toolbar.style.height = TOOLBAR.height + SCREEN.topbar + 'px';
		toolbar.style.paddingTop = SCREEN.topbar + 'px';
		var canvas = document.getElementById("canvas");
		canvas.height = SCREEN.height - SCREEN.topbar - TOOLBAR.height;
		canvas.width = SCREEN.width;
		var can = canvas.getContext('2d');
        // --------Init End-------------

		// --------Init TOOLBAR----------
		var tools = [{
			"name": "1",
			"default": {
				"height": 50,
				"width": 50,
				"color": "red",
				"position": "out"
			},
			"icon": "./11.png"
		}, {
			"name": "2",
			"default": {
				"height": 50,
				"width": 50,
				"color": "green",
				"position": "in"
			},
			"icon": "./11.png"
		}, {
			"name": "3",
			"default": {
				"height": 50,
				"width": 50,
				"color": "blue",
				"position": "out"
			},
			"icon": "./11.png"
		}];
		initToolBar(tools);
		//---------Init End------------

        window.onload = function() {
            document.getElementById("scale").innerText = (scale * 100).toFixed(2) + '米';
            var segments = reshapeBlocks(INIT, IN, OUT, scale);
            console.log("segments:");
            console.log(segments);
            setColor("#000");
            for(var i = 0; i < segments.length; i ++) {
                can.moveTo(segments[i].x1, segments[i].y1);
                can.lineTo(segments[i].x2, segments[i].y2);
                can.stroke();
            }
        };


		//-------Functions------------

		/**
		 * InitToolBar 初始化工具栏,根据tools数组的内容创建工具图标并添加拖动事件
		 * @param {Array} tools 要初始化的工具列表
		 */
		function initToolBar(tools) {
			for (var i = 0; i < tools.length; i++) {
				var tool = document.createElement("span");
				tool.className = "tool";
				tool.setAttribute("name", tools[i].name);
				tool.innerHTML = '<img src="' + tools[i].icon + '"/>';
				if (tools[i].default.position == "out") {
					tool.addEventListener("tap", function() {
						Drag(document.getElementById(this.getAttribute("name")), putBlockOut)
					})
				} else {
					tool.addEventListener("tap", function() {
						Drag(document.getElementById(this.getAttribute("name")), putBlockIn)
					})
				}

				console.log("Tools loading...")
				toolbar.appendChild(tool);
				var block = document.createElement("div");
				if (tools[i].default.position == "out") {
					block.setAttribute("style", "height:" + tools[i].default.height + "px;width:" + tools[i].default.width + "px;border:2px solid " + tools[i].default.color + ";");
				} else {
					block.setAttribute("style", "height:" + tools[i].default.height + "px;width:" + tools[i].default.width + "px;background-color: " + tools[i].default.color + ";");
				}
				block.setAttribute("data-type", tools[i].default.position);
				block.className = "block";
				block.setAttribute("id", tools[i].name);
				document.body.appendChild(block);
			}
		}

		/**
		 * 重绘画布
		 * @param {Function} callback 重绘完成的成功回调
		 */
		function reDraw(callback) {
			clearCanvas();
			can.strokeRect(INIT.x1, INIT.y1, INIT.x2 - INIT.x1, INIT.y2 - INIT.y1);
			for (var a = 0; a < IN.length; a++) {
				can.fillRect(IN[a].x1, IN[a].y1, IN[a].x2 - IN[a].x1, IN[a].y2 - IN[a].y1);
			}
			for (var b = 0; b < OUT.length; b++) {
				can.strokeRect(OUT[b].x1, OUT[b].y1, OUT[b].x2 - OUT[b].x1, OUT[b].y2 - OUT[b].y1);
			}
		}

		/**
		 * 设置canvas画笔颜色
		 * @param {String} color
		 */
		function setColor(color) {
			can.strokeStyle = color;
			can.fillStyle = color;
		}

		/**
		 * 设置canvas画笔粗细
		 * @param {Number} width
		 */
		function setLineWidth(width) {
			can.lineWidth = width;
		}

		/**
		 * 清空画布
		 */
		function clearCanvas() {
			can.clearRect(0, 0, SCREEN.width, SCREEN.height - TOOLBAR.height - SCREEN.topbar);
		}

        /**
         * 将块块变成多边形户型图
         * @return {Array}     返回点列表
         */
        function reshapeBlocks(initBlock, inBlocks, outBlocks, scale) {
            var eps = 0.001 / scale;
            function feq(x, y) {
                return Math.abs(x - y) <= eps;
            };
            function flt(x, y) {
                return x - y < -eps;
            }
            function fgt(x, y) {
                return x - y > eps;
            }
            // function isOnInitBlock(p) {
            //     var x = p.x, y = p.y;
            //     if(feq(x, initBlock.x1) || feq(x, initBlock.x2)) {
            //         if(!flt(y, initBlock.y1) && !fgt(y, initBlock.y2)) {
            //             return true;
            //         }
            //     }
            //     if(feq(y, initBlock.y1) || feq(y, initBlock.y2)) {
            //         if(!flt(x, initBlock.x1) && !fgt(y, initBlock.x2)) {
            //             return true;
            //         }
            //     }
            //     return false;
            // }
            function isInInitBlock(p) {
                var x = p.x, y = p.y;
                return !flt(x, initBlock.x1) && !fgt(x, initBlock.x2) && !flt(y, initBlock.y1) && !fgt(y, initBlock.y2);
            }
            function isOnSegment(p, sp1, sp2) {
                if(feq(sp1.x, sp2.x)) {
                    if(feq(p.x, sp1.x) && !flt(p.y, sp1.y) && !fgt(p.y, sp2.y)) {
                        return true;
                    }
                }
                if(feq(sp1.y, sp2.y)) {
                    if(feq(p.y, sp1.y) && !flt(p.x, sp1.x) && !fgt(p.x, sp2.x)) {
                        return true;
                    }
                }
                return false;
            }
            var points = {
                p: [],
                eq: function(p1, p2) {
                    return feq(p1.x, p2.x) && feq(p1.y, p2.y);
                },
                add: function(x, y) {
                    var p = {x: x, y: y};
                    var isNew = true;
                    for(var i = 0; i < this.p.length; i ++) {
                        if (this.eq(p, this.p[i])) {
                            isNew = false;
                            break;
                        }
                    }
                    if (isNew) {
                        this.p.push(p);
                    }
                },
                id: function(p) {
                    for(var i = 0; i < this.p.length; i ++) {
                        if (this.eq(p, this.p[i])) {
                            return i;
                        }
                    }
                },
                filter: function(sp1, sp2) {
                    var res = [];
                    for(var i = 0; i < this.p.length; i ++) {
                        if(isOnSegment(this.p[i], sp1, sp2)) {
                            res.push(this.p[i]);
                        }
                    }
                    res.sort(function(a, b) {
                        if(!feq(a.x, b.x)) {
                            return a.x < b.x ? -1 : 1;
                        }
                        return a.y < b.y ? -1 : 1;
                    });
                    return res;
                },
            };
            var graph = {
                next: undefined,
                init: function() {
                    var size = points.p.length;
                    this.next = Array(size);
                    for(var i = 0; i < size; i ++) {
                        this.next[i] = [];
                    }
                },
                add: function(p1, p2, d) {
                    var i1 = points.id(p1), i2 = points.id(p2);
                    var e = {pid: i2, d: d};
                    var isNew = true;
                    for(var i = 0; i < this.next[i1].length; i ++) {
                        var t = this.next[i1][i];
                        if(t.pid === e.pid) {
                            isNew = false;
                            break;
                        }
                    }
                    if(isNew) {
                        this.next[i1].push(e);
                    }
                },
                /**
                 * 方向，右：0，下：1，左：2，上：3，
                 * @param  {Object} sp 起点
                 * @param  {Object} sd 初始方向
                 * @return {Array}     返回点列表
                 */
                walk: function(sp, sd) {
                    var res = [];
                    var sid = points.id(sp);
                    res.push(points.p[sid]);
                    can.moveTo(res[0].x, res[0].y);
                    var pd = sd; // 上一次的方向
                    var cid = sid; // 当前节点id
                    var vis = Array(points.p.length);
                    for(var i = 0; i < vis.length; i ++) {
                        vis[i] = false;
                    }
                    function choose(d, list) {
                        for(var i = 0; i < list.length; i ++) {
                            if(d[list[i]] !== undefined) {
                                return list[i];
                            }
                        }
                        throw Error("Cannot choose one way.");
                    }
                    do {
                        // console.log("cid");
                        // console.log(cid);
                        var edges = this.next[cid];
                        edges = edges.filter(function(a) {
                            // 过滤掉反向边
                            if(4 - a.d === pd) {
                                return false;
                            }
                            return true;
                        });
                        var d = Array(4);
                        for(var i = 0; i < edges.length; i ++) {
                            d[edges[i].d] = edges[i];
                        }
                        var p = points.p[cid];
                        // can.lineTo(p.x, p.y);
                        // can.stroke();
                        var di;
                        // console.log("p: ");
                        // console.log(p);
                        // console.log("d: ");
                        // console.log(d);
                        if(isOnSegment(p, {x: initBlock.x1, y: initBlock.y1}, {x: initBlock.x2, y: initBlock.y1})) {
                            if(points.eq(p, {x: initBlock.x1, y: initBlock.y1}) && (pd == 1 || pd == 3)) {
                                di = choose(d, [2, 0, 3]);
                            } else {
                                di = choose(d, [3, 1, 0]);
                            }
                        } else if(isOnSegment(p, {x: initBlock.x2, y: initBlock.y1}, {x: initBlock.x2, y: initBlock.y2})) {
                            di = choose(d, [0, 2, 1]);
                        } else if(isOnSegment(p, {x: initBlock.x1, y: initBlock.y2}, {x: initBlock.x2, y: initBlock.y2})) {
                            di = choose(d, [1, 3, 2]);
                        } else if(isOnSegment(p, {x: initBlock.x1, y: initBlock.y1}, {x: initBlock.x1, y: initBlock.y2})) {
                            di = choose(d, [2, 0, 3]);
                        } else if(isInInitBlock(p)) {
                            di = choose(d, [(pd + 1) % 4, pd, (pd + 3) % 4]);
                        } else {
                            di = choose(d, [(pd + 3) % 4, pd, (pd + 1) % 4]);
                        }
                        pd = d[di].d, cid = d[di].pid;
                        res.push(points.p[cid]);
                        if(vis[cid]) {
                            throw Error("Error occurred when reshape blocks.");
                        } else {
                            vis[cid] = true;
                        }
                    } while(cid !== sid);
                    return res;
                },
            };
            function addBlock(block, clockwise) {
                var p = [{x: block.x1, y: block.y1}, {x: block.x2, y: block.y1}, {x: block.x2, y: block.y2}, {x: block.x1, y: block.y2}];
                p.push(p[0]);
                if(clockwise) {
                    for(var i = 0; i < 4; i ++) {
                        var d = i;
                        var arr;
                        if(i < 2) {
                            arr = points.filter(p[i], p[i + 1]);
                        } else {
                            arr = points.filter(p[i + 1], p[i]);
                            arr.reverse();
                        }
                        for(var j = 0; j < arr.length - 1; j ++) {
                            graph.add(arr[j], arr[j + 1], d);
                        }
                    }
                } else {
                    for(var i = 3; i >= 0; i --) {
                        var d = (i + 2) % 4;
                        var arr;
                        if(i < 2) {
                            arr = points.filter(p[i], p[i + 1]);
                            arr.reverse();
                        } else {
                            arr = points.filter(p[i + 1], p[i]);
                        }
                        for(var j = 0; j < arr.length - 1; j ++) {
                            graph.add(arr[j], arr[j + 1], d);
                        }
                    }
                }
            }
            function pickStartPoint() {
                var p = points.p[0];
                var n = points.p.length;
                for(var i = 1; i < n; i ++) {
                    var t = points.p[i];
                    if(flt(t.y, p.y) || (feq(t.y, p.y) && flt(t.x, p.x))) {
                        p = t;
                    }
                }
                if(!(p.x === initBlock.x1 && p.y === initBlock.y1)) {
                    return p;
                }
                var block = undefined;
                for(var i = 0; i < inBlocks.length; i ++) {
                    if(points.eq(p, {x: inBlocks[i].x1, y: inBlocks[i].y1})) {
                        block = inBlocks[i];
                        break;
                    }
                }
                if(block === undefined) {
                    return p;
                }
                return {x: block.x2, y: block.y2};
            }
            function getDirection(p1, p2) {
                if(!feq(p1.x, p2.x)) {
                    return flt(p1.x, p2.x) ? 0 : 2;
                }
                return flt(p1.y, p2.y) ? 1 : 3;
            }
            function mergeToSegments(plist) {
                var res = [];
                var pi = 0, pd = getDirection(plist[0], plist[1]);
                for(var i = 1; i < plist.length; i ++) {
                    var d = i < plist.length - 1 ? getDirection(plist[i], plist[i + 1]) : -1;
                    if(d !== pd) {
                        res.push({x1: plist[pi].x, y1: plist[pi].y, x2: plist[i].x, y2: plist[i].y});
                        pi = i, pd = d;
                    }
                }
                return res;
            }

            // ------------ begin ------------
            points.add(initBlock.x1, initBlock.y1);
            points.add(initBlock.x1, initBlock.y2);
            points.add(initBlock.x2, initBlock.y1);
            points.add(initBlock.x2, initBlock.y2);
            var blocks = inBlocks.concat(outBlocks);
            for(var i = 0; i < blocks.length; i ++) {
                points.add(blocks[i].x1, blocks[i].y1);
                points.add(blocks[i].x1, blocks[i].y2);
                points.add(blocks[i].x2, blocks[i].y1);
                points.add(blocks[i].x2, blocks[i].y2);
            }
            graph.init();
            addBlock(initBlock, true);
            for(var i = 0; i < inBlocks.length; i ++) {
                addBlock(inBlocks[i], false);
            }
            for(var i = 0; i < outBlocks.length; i ++) {
                addBlock(outBlocks[i], true);
            }
            return mergeToSegments(graph.walk(pickStartPoint(), 0));
        }
	</script>

</body>

</html>
